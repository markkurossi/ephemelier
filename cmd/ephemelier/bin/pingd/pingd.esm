// -*- go -*-
//
// Copyright (c) 2025 Markku Rossi
//
// All rights reserved.
//

package main

import (
	"ephemelier/kernel"
	"ephemelier/ports"
)

type Memory struct {
	pid   uint32
	port  int32
	count uint32
}

// XXX memory always initialized in Init
//
// XXX Next() with syscall that returns variable data => next state marked
// as dynamic, no explicit marking needed.

func Init() {
	Next(StGetPidResult, SysGetpid)
}

func StGetPidResult() {
	if g.arg0 < 0 {
		Exit(1)
	}
	mem.pid = uint32(g.arg0)

	Next(StGetportResult, SysGetport, mem.pid)
}

func StGetportResult() {
	if g.arg0 < 0 {
		Exit(1)
	}
	mem.port = g.arg0

	Next(StReceive, SysYield)
}

func StReceive() {
	if g.arg0 < 0 {
		Exit(1)
	}

	Next(StReceiveResult, SysRead, mem.port, nil, 1024)
}

func DynStReceiveResult() {
	if g.arg0 < 0 || e.arg0 < 0 {
		Exit(1)
	}
	if g.arg0 == 0 || e.arg0 == 0 {
		Exit(0)
	}
	Next(StDecodeMsg, SysYield, 1)
}

func DynStDecodeMsg() {
	msg, ok := ports.DecodeMsg(g.argBuf, e.argBuf)
	if !ok {
		Next(0, SysExit, 1)
	}

	var reply [len(msg) + 2]byte

	size := copy(reply, msg)
	reply[size] = '\r'
	reply[size+1] = '\n'

	size += 2

	Next(StWriteResult, SysWrite, 1, reply, size)
}

func StWriteResult() {
	if g.arg0 < 0 {
		Exit(1)
	}
	mem.count++

	Next(StCreatemsgResult, SysCreatemsg, mem.port)
}

func DynStCreatemsgResult() {
	if g.arg0 < 0 {
		Exit(1)
	}

	msg := ports.EncodeMsg(g.argBuf, e.Argbuf, []byte("Hello, ping!"))

	Next(StReceive, SysWrite, mem.port, msg, len(msg))
}
