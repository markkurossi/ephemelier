// -*- go -*-
//
// Copyright (c) 2025-2026 Markku Rossi
//
// All rights reserved.
//

package main

import (
	"crypto/cipher/chacha20poly1305"
	"encoding/binary"
	"ephemelier/fs"
	"ephemelier/kernel"
	"ephemelier/memory"
	"ephemelier/memory/semihonest"
)

func main(g memory.G, e memory.E) (
	[]byte, kernel.PC, kernel.Syscall, int32, []byte, int32) {

	if g.arg0 < 0 {
		return nil, 0, kernel.SysExit, g.arg0, nil, 0
	}
	if len(g.argBuf) == 0 {
		return nil, intern(StPrompt), kernel.SysContinue, 0, nil, 0
	}

	nonce, mem, ok := semihonest.Decode(g.mem, g.key, e.key)
	if !ok {
		return nil, 0, kernel.SysExit, -kernel.EINVAL, nil, 0
	}

	block := binary.GetUint32(mem[fs.MemOfsBlock:])
	size := binary.GetUint64(mem[fs.MemOfsPlainSize:])

	// Create nonce.

	var nonce [fs.NonceSize]byte
	copy(nonce, mem[fs.MemOfsNonce:])

	var seq [8]byte
	seq = binary.PutUint64(seq, 0, uint64(block))
	for i := 0; i < len(seq); i++ {
		nonce[4+i] ^= seq[i]
	}

	// Create AAD.
	var aad [fs.AADSize]byte
	aad = binary.PutUint32(aad, fs.AADOfsBlock, block)
	aad = binary.PutUint64(aad, fs.AADOfsFileSize, size)

	plain, ok := chacha20poly1305.Open(mem[fs.MemOfsKey:fs.MemOfsFD], nonce,
		g.argBuf, aad[:])
	if !ok {
		return nil, 0, kernel.SysExit, -kernel.EINVAL, nil, 0
	}

	mem = binary.PutUint32(mem, fs.MemOfsBlock, block+1)

	return semihonest.Encode(nonce, mem, g.key, e.key),
		intern(StFileWriteResult), kernel.SysWrite, 1, plain, len(plain)
}
