// -*- go -*-
//
// Copyright (c) 2025 Markku Rossi
//
// All rights reserved.
//

package kernel

import (
	"crypto/cipher/gcm"
	"encoding/binary"
)

type PC = uint16

// Syscall defines the system calls.
type Syscall = uint8

const (
	// SysExit exits the process.
	SysExit      = 1
	SysSpawn     = 2
	SysPeek      = 3
	SysRead      = 4
	SysSkip      = 5
	SysWrite     = 6
	SysOpen      = 7
	SysClose     = 8
	SysWait      = 9
	SysGetrandom = 10
	SysYield     = 11
	SysGetpid    = 12

	SysGetport    = 100
	SysCreateport = 101
	SysSendport   = 102
	SysRecvport   = 103
	SysCreatemsg  = 104
)

const (
	KeySize   = 16
	NonceSize = 12
	TagSize   = 16
)

// PeerResult implements syscall interface with result argument for
// garbler and evaluator.
type PeerResult struct {
	arg0 int32
}

// PeerInit implements syscall interface for program initialization.
type PeerInit struct {
	arg0      int32
	privShare [KeySize]byte
}

type G struct {
	arg0      int32
	privShare [KeySize]byte
	mem       []byte
	argBuf    []byte
	arg1      int32
}

type E struct {
	arg0      int32
	privShare [KeySize]byte
	argBuf    []byte
}

type G1B struct {
	arg0      int32
	privShare [KeySize]byte
	mem       [NonceSize + 16 + TagSize]byte
	argBuf    [0]byte
	arg1      int32
}

type E1B struct {
	arg0      int32
	privShare [KeySize]byte
}

func EncodeMemory(nonce, mem, key []byte) []byte {
	ctr := binary.GetUint(nonce)
	ctr += 1
	nonce = binary.PutUint(nonce, 0, ctr)

	var memory [len(nonce) + len(mem) + 16]byte
	copy(memory, nonce)

	cipher := gcm.EncryptAES128(key, nonce, mem, nil)
	copy(memory[len(nonce):], cipher)

	return memory
}

func DecodeMemory(cipher, key []byte) ([]byte, []byte, bool) {
	nonce := cipher[:NonceSize]
	mem, ok := gcm.DecryptAES128(key, nonce, cipher[NonceSize:], nil)
	return nonce, mem, ok
}
