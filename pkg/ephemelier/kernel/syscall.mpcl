// -*- go -*-
//
// Copyright (c) 2025 Markku Rossi
//
// All rights reserved.
//

package kernel

import (
	"crypto/cipher/gcm"
	"encoding/binary"
)

type PC = uint16

// Syscall defines the system calls.
type Syscall = uint8

const (
	// SysExit exits the process.
	SysExit      = 1
	SysSpawn     = 2
	SysPeek      = 3
	SysRead      = 4
	SysSkip      = 5
	SysWrite     = 6
	SysOpen      = 7
	SysClose     = 8
	SysDial      = 9
	SysListen    = 10
	SysAccept    = 11
	SysWait      = 12
	SysGetrandom = 13
	SysTlsserver = 14
	SysTlsclient = 15
	SysTlshs     = 16
	SysTlsstatus = 17
	SysContinue  = 18
	SysYield     = 19
	SysNext      = 20
	SysGetpid    = 21
	SysChroot    = 22

	SysGetport    = 100
	SysCreateport = 101
	SysSendfd     = 102
	SysRecvfd     = 103
	SysCreatemsg  = 104
)

const (
	KeySize   = 16
	NonceSize = 12
	TagSize   = 16
)

// PeerResult implements syscall interface with result argument for
// garbler and evaluator.
type PeerResult struct {
	arg0 int32
}

// PeerInit implements syscall interface for program initialization.
type PeerInit struct {
	arg0 int32
	key  [KeySize]byte
}

type G struct {
	arg0   int32
	key    [KeySize]byte
	mem    []byte
	argBuf []byte
	arg1   int32
}

type E struct {
	arg0   int32
	key    [KeySize]byte
	argBuf []byte
}

type G1B struct {
	arg0   int32
	key    [KeySize]byte
	mem    [NonceSize + 16 + TagSize]byte
	argBuf [0]byte
	arg1   int32
}

type E1B struct {
	arg0 int32
	key  [KeySize]byte
}

func EncodeMem(nonce, mem, gkey, ekey []byte) []byte {
	var key [kernel.KeySize]byte
	for i := 0; i < kernel.KeySize; i++ {
		key[i] = gkey[i] ^ ekey[i]
	}

	ctr := binary.GetUint(nonce)
	ctr += 1
	nonce = binary.PutUint(nonce, 0, ctr)

	var memory [len(nonce) + len(mem) + 16]byte
	copy(memory, nonce)

	cipher := gcm.SealAES128(key, nonce, mem, nil)
	copy(memory[len(nonce):], cipher)

	return memory
}

func DecodeMem(cipher, gkey, ekey []byte) ([]byte, []byte, bool) {
	var key [kernel.KeySize]byte
	for i := 0; i < kernel.KeySize; i++ {
		key[i] = gkey[i] ^ ekey[i]
	}

	nonce := cipher[:NonceSize]
	mem, ok := gcm.OpenAES128(key, nonce, cipher[NonceSize:], nil)
	return nonce, mem, ok
}
